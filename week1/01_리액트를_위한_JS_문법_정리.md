# 리액트를 위한 JS 문법 정리

+ const let
+ template string
+ arrow function
+ .bind(this)
+ const {children} = this.props;
+ ...props
+ Promise
+ async await
+ Generator

<br>

## var는 문제아

1. 헷갈리는 함수 레벨 스코프

   ```javascript
   // var.js
   
   // 1. 헷갈리는 함수 레벨 스코프
   
   (function() {
     if (true) {
         var variable = 'function scope';
     }  
     
     console.log(variable); // function scope
   })();
   ```

2. 중복 선언이 가능

   ```javascript
   // var.js
   
   // 2. 중복 선언이 가능
   
   (function() {
       var variable = 'function scope';
       var variable = 'duplicated';
       
       console.log(variable); // duplicated
   })();
   ```

3. 생략도 가능

   ```javascript
   // var.js
   
   // 3. 생략도 가능
   
   (function() {
       variable = 'no var';
       
       console.log(variable);
   })();
   
   console.log(variable);
   ```

4. 호이스팅

   ```javascript
   // var.js
   
   // 4. 호이스팅
   
   (function() {
       console.log(variable); // undefined
       
       var variable = 'hoisted';
   })();
   
   (function() {
       var variable;
       
       console.log(variable); // undefined
       
       variable = 'hoisted';
   })();
   ```

<br>

## let 은 해결사

1. 블록 레벨 스코프

   ```javascript
   // let.js
   
   // 1. 블록 레벨 스코프
   {
       let variable = 'block scope';
       
       console.log(variable); // block scope
   }
   ```

2. 중복 선언 => syntax error

   ```javascript
   // 2. 중복 선언 => SyntaxError
   {
       let variable = 'block scope';
       let variable = 'duplicated';
       
       console.log(variable); // SyntaxError: Identifier 'variable' has already been declared (4:6)
   }
   ```

3. 호이스팅 => syntax error

   ```javascript
   // 3. 호이스팅 => ReferenceError
   {
       console.log(variable);
       let variable = 'hoisted';
   }
   ```

<br>

## let 은 변경 가능, const 는 불가능

+ **Primitive**: 그 자체로 값이 되는 간단한 값(String, Number, boolean 등)

  ```javascript
  // const.js
  
  // Primitive
  let a = 'a';
  a = 'b';
  a;
  
  const c = 'c';
  c = 'd'; // TypeError
  c;
  ```

+ **Reference**: Object가 가지고 있는 데이터를 가리키는 무언가를 참조
  (실제 값이 아닌 실제 값을 가리키는 참조값)

  ```javascript
  // Reference
  let e = {
      foo: 'foo',
  };
  e = {
      bar: 'bar',
  }
  e;
  
  const f = {
      foo: 'foo',
  };
  // f = {
  // 	foo: 'bar',
  // }; // TypeError
  f.foo = 'bar';
  f;
  ```

<br>

## template string

+ ```javascript
  `문자열`
  ```

+ ```javascript
  `${자바스크립트 표현식}`
  ```

  ```javascript
  // string.js
  
  const name = 'Mark';
  
  console.log('안녕하세요.\n제 이름은 ' + name + ' 입니다.');
  
  console.log(`안녕하세요.
  제 이름은 ${name} 입니다.`);
  ```

<br>

## arrow function

+ 자신의 this를 만들지 않는다.

+ 생성자로 사용할 수 없다.

+ 항상 익명 함수

+ 리턴만 있으면, {} 생략

+ 인자가 하나면, () 생략

  ```javascript
  // arrow.js
  
  function Foo() {
      this.name = 'Mark';
      
      setTimeout(function() {
          console.log(this.name); // undefined
      }, 1000);
      
      setTimeout(() => {
          console.log(this.name); // Mark
      }, 1000);
  }
  
  const foo = new Foo();
  ```

  ```javascript
  // 익명 함수를 변수에 대입해서 사용
  const a = () => {
      return '리턴';
  };
  
  console.log(a()); // 리턴
  
  // 리턴이 바로 표현 가능하면, { return } 생략
  const b = () => '리턴';
  
  console.log(b()); // 리턴
  
  // 매개변수가 한개면 () 생략
  const c = props => `리턴 ${props}`;
  
  console.log(c('프롭스'));
  
  
  () => a => b => c => d;
  ```

  

